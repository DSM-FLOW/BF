# 시간 차원의 모델링

이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 동일한 전제를 기반으로 한다.

</br>

## 이벤트 소싱

```
"순서도만 보여주고 테이블을 숨기면 상대가 계속 어리둥절할 것이다. 테이블을 보여주면 일반적으로 순서도는 필요 없게 된다. 테이블의 정보만으로도 명백하기 때문이다."
																							   - 프레드 브룩스
```

테이블의 수명주기 동안 어떤 일이 발생했는지 알 수 없다. 우리가 아는 것은 리드의 현재 상태뿐이다.  누락된 정보를 채우는 방법 중 하나는 이벤트 소싱을 사용하는 것이다.

이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입한다.

애그리게이트의 현재 상태를 반영하는 스키마 대신 이벤트 소싱 기반 시스템은 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지한다.

</br>

#### 검색

검색 기능을 구현해야 한다고 가정해보자.그러나 리드의 연락처 정보는 업데이트될 수 있으므로 영업 담당자는 다른 담당자가 적용한 변경사항을 인지하지 못할 수 있으며 기록 값을 포함한 연락처 정보를 사용하여 리드를 찾으려 할 수 있다.

이벤트 소싱을 사용하면 과거 정보를 쉽게 프로젝션할 수 있다.

</br>

#### 분석

구현한 로직은 검색 최적화와 분석 최적화 모델을 메모리에서 프로젝션한다. 그러나 실제로 필요한 기능을 구현하려면 프로젝션된 모델을 데이터베이스에 유지해야 한다.

</br>

#### 원천 데이터

이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다.

시스템의 이벤트를 저장하는 데이터베이스는 유일하고 강력하게 일관될 저장소인 시스템의 원천 데이터다.

이벤트를 저장하는 데 사용되는 데이터베이스를 **이벤트 스토어**라고 한다.

</br>

#### 이벤트 스토어

> 추가만 가능한 저장소이므로 이벤트를 수정하거나 삭제할 수 없다.

</br>

## 이벤트 소싱 도메인 모델

> 애그리게이트의 수명주기를 모델링하기 위해 독점적으로 도메인 이벤트를 사용한다.

애그리게이트 상태에 대한 모든 변경사항은 도메인 이벤트로 표현돼야 한다.

- 애그리게이트의 도메인 이벤트를 로드한다.
- 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성한다. 
- 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 두메인 이벤트를 생성한다.
- 새 도메인 이벤트를 이벤트 스토어에 커밋한다.

</br>

#### 장점

애그리게이트의 현재 상태만을 데이터베이스에 유지하는 기존 모델에 비해 이벤트 소싱 도메인 모델은 애그리게이트를 모델링하는 데 더 많은 노력이 필요하다.

##### 시간 여행

도메인 이벤트를 사용하여 애그리게이트의 현재 상태를 재구성할 수 있는 것처럼 도메인 이벤트는 애그리게이트의 모든 과거 상태를 복원하는 데도 사용할 수 있다.

##### 심오한 통찰력

기존 이벤트의 데이터를 활용하여 추가 통찰력을 제공할 새로운 프로젝션 방법을 언제든지 추가할 수 있다.

##### 감사 로그

영속적인 도메인 이벤트는 애그리게이트 상태에 발생한 모든 것에 대한 강력하게 일관된 감사 로그를 나타낸다.

##### 고급 낙관적 동시성 제어

고급 낙관적 동시성 모델은 읽기 데이터가 기록되는 동안 다른 프로세스에 의해 덮어 쓰여지는 경우 예외를 발생시킨다.

</br>

#### 단점

이벤트 소싱 도메인 모델의 문제점

##### 학습 곡선

패턴을 성공적으로 구현하려면 팀 교육과 새로운 사고 방식에 익숙해지는 시간이 필요하다.

##### 모델의 진화

이벤트 소싱 모델을 발전시키는 것은 어려울 수 있다.

##### 아키텍처 복잡성

이벤트 소싱을 구현하면 수많은 아키텍처의 '유동적인 부분'이 도인되어 전체 설계가 더 복잡해진다.

</br>

## 자주 묻는 질문

이벤트 소싱 패턴을 소개할 때 엔지니어는 종종 몇 가지 일반적인 질문을 한다.

</br>

#### 성능

이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능에 부정적인 영향을 준다. 이벤트가 추가되면서 성능이 저하된다. 이것이 어떻게 작동할 수 있을까?

이벤트를 상태 표현 방식으로 프로젝션하려면 실제로 컴퓨팅 성능이 필요하며 애그리게이트 목록에 더 많은 이벤트가 추가됨에 따라 그 필요성은 더 커진다.

</br>

#### 데이터 삭제

이벤트 스토어는 추가 전용 데이터베이스지만 물리적으로 데이터를 삭제해야 하는 경우에는 어떻게 할까?

이런 요구사항은 잊어버릴 수 있는 페이로드 패턴으로 해결할 수 있다.

</br>

#### 이렇게 하면 안될까요...?

텍스트 파일에 로그를 작성하여 감사 로그로 사용할 수 없는 이유는?

> 실시간 데이터 처리 데이터베이스와 로그 파일 모두에 데이터를 쓰는 것은 오류가 발생하기 쉬운 작업이다.

상태 기반 모델을 계속 사용할 수 없지만 동일한 데이터베이스 트랜잭션에서 로그를 로그 테이블에 추가할 수 없는 이유는?

>인프라 관점에서 이 접근 방식은 상태와 로그 레코드 간의 일관된 동기화를 제공한다.

상태 기반 모델을 계속 사용할 수 없지만 레코드의 스냅숏을 만들어 전용 '이력' 테이블에 복사하는 데이터베이스 트리거를 추가할 수 없는 이유는?

>이 접근 방식은 이전 방식의 단점을 극복한다. 로그 테이블에 레코드를 추가하기 위해 명시적으로 수동 호출이 필요하지 않다.

</br>

## 결론

이벤트 소싱 패턴과 도메인 모델의 애그리게이트에서 시간 차원을 모델링을 적용하는 방식을 설명함.

이벤트 소싱 도메인 모델에서 애그리게이트 상태에 대한 모든 변경사항은 일련의 도메인 이벤트로 표현된다.

결과 도메인 이벤트는 애그리게이트의 현재 상태를 프로젝션 하는데 사용할 수 있다.

이벤트 기반 모델은 이벤트를 특정 작업에 최적화된 여러 표현 모델로 프로젝션할 수 있는 유연성을 제공한다.

이 패턴은 분석과 최적화를 위해, 또는 법적으로 감사 로그를 요구하기 때문에 시스템 데이터에 대한 심오한 통찰력이 필요한 경우에 적합하다.

</br>

# 느낀점

이벤트 소싱 패턴과 도메인 모델의 애그리게이트에서 시간 차원을 모델링을 적용하는 방식을 알게 되었다.