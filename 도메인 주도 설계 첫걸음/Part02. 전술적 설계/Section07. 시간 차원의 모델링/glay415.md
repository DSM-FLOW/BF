### 07 _ 시간 차원의 모델링

---

**이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 동일한 전제를 기반으로 한다.**

#### 이벤트 소싱

---

> **순서도만 보여주고 테이블을 숨기면 상대가 계속 어리둥절할 것이다. 테이블을 보여주면 일반적으로 순서도는 필요 없게 된다. 테이블의 정보만으로도 명백하기 때문이다. **
>
> **- 프레드 브룩스(Fred Brooks)**

우리는 테이블의 스키마와 테이블에 저장된 데이터를 분석하는 것만으로도 수집할 수 있는 정보가 상당히 많다.

하지만 해당 테이블의 수명주기 동안 어떤 일이 발생했는지 알 수 없다. 우리가 아는 것은 리드의 현재 상태뿐이다.누락된 정보를 채우는 방법 중 하나는 이벤트 소싱을 사용하는 것이다.



이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입한다.

애그리게이트의 현재 상태를 반영하는 스키마 대신 이벤트 소싱 기반 시스템은 애그리게이틍의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지한다.

``` json
{
    "lead-id" : 12,
    "event-id" : 0,
    "event-type" : "lead-initialized",
    "first-name" : "Casey",
    "last-name" : "David",
    "phone-number" : "555-2951",
    "timestamp" : "2020-05-20T09:52:55.95Z"
},
{
    "lead-id" : 12,
    "event-id" : 1,
    "event-type" : "contacted",
    "timestamp" : "2020-05-20T12:32:08.24Z"
}
```

위 목록은 이벤트 소싱 시스템에서 개인의 데이터가 표현되는 방식을 보여준다.

위 목록의 이벤트는 고객의 이야기를 알려준다.

고객의 상태는 이러한 도메인 이벤트로부터 쉽게 프로젝션 할 수 있다. 간단한 변환 로직을 각 이벤트에 순차적으로 적용하면 된다.

##### 검색

검색 기능을 구현한다고 가정해보자.

담당자가 변경된 정보를 인지하지 못할 수 있으며 기록 값을 포함한 연락처 정보를 사용하여 검색 할 수 있다.

이벤트 소싱을 사용하면 과거 정보를 쉽게 프로젝션할 수 있다.

##### 분석

좀 더 분석하기 편한 데이터가 필요할 수 있다.

검색 최적화와 분석 최적화 모델을 메모리에서 프로젝션 하려면 실제 필요한 기능을 위해 프로젝션된 모델을 데이터베이스에 유지해야 한다.

##### 원천데이터

이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다. 이러한 이벤트는 시스템의 원천 데이터가 된다.

![image](https://user-images.githubusercontent.com/80652992/184727780-5db01051-201a-4969-9a66-817e0d8484dd.png)

시스템의 이벤트를 저장하는 데이터베이스는 유일하고 강력하게 일관된 저장소인 시스템의 원천 데이터다.

이벤트를 저장하는데 사용되는 데이터베이스를 지칭하는 이름이 이벤트 스토어다.

##### 이벤트 스토어

이벤트 스토어는 추가만 가능한 저장소이므로 이벤트를 수정하거나 삭제할 수 없다.

이벤트 스토어는 특정 비즈니스 엔티티에 속한 모든 이벤트를 가져오고 이벤트를 추가하는 기능을 지원해야 한다.



#### 이벤트 소싱 도메인 모델

---

원래 도메인 모델은 애그리게이트의 상태 표현 방식을 유지 관리하고 선택 도메인 이벤트를 내보낸다.

이벤트 소싱 도메인 모델은 애그리게이트의 수명주기를 모델링하기 위해 독점적으로 도메인 이벤트를 사용한다.

이벤트 소싱 애그리게이트에 대한 각 작업은 다음 단계를 따른다.

- 애그리게이트의 도메인 이벤트를 로드한다.
- 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성한다.
- 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성한다.
- 새 도메인 이벤트를 이벤트 스토어에 커밋한다.

##### 장점

시간 여행

도메인 이벤트를 사용하여 애그리게이트의 현재 상태를 재구성할 수 있는 것처럼 도메인 이벤트는 애그리게이트의 모든 과거 상태를 복원하는 데도 사용할 수 있다. 즉, 애그리게이트의 모든 과거 상태를 필요할 때 언제든 재구성할 수 있다.

시간 여행은 시스템의 동작을 분석하고, 시스템의 의사결정을 검사하고, 비즈니스 로직을 최적화할 때 종종 필요하다.

과거 상태를 재구성하는 또 다른 일반적인 유스케이스는 소급 디버깅이다(retroactive debugging). 애그리게이트를 정확히 버그가 관찰됐을 때의 상태로 되돌릴 수 있다.

심오한 통찰력

이벤트 소싱은 시스템의 상태와 동작에 대한 깊은 통찰력을 제공한다. 이벤트 소싱은 이벤트를 다른 상태 표현 방식으로 변환할 수 있는 유연한 모델을 제공한다. 기존 이벤트의 데이터를 활용하여 추가 통찰력을 제공할 새로운 프로젝션 방법을 언제든지 추가할 수 있다.

감사 로그

영속적인 도메인 이벤트는 애그리게이트 상태에 발생한 모든 것에 대한 강력하게 일관된 감사 로그(audit log)를 나타낸다. 법률에 따라 일부 비즈니스 도메인은 이러한 감사 로그를 반드시 구현해야 하며 이벤트 소싱은 이를 즉시 제공한다.

이 모델은 화폐 또는 금전 거래를 관리하는 시스템에 잘 이용된다. 이를 통해 시스템의 의사결정과 계정 간의 자금 흐름을 쉽게 추적할 수 있다.

고급 낙관적 동시성 제어

고급 낙관적 동시성 모델은 읽기 데이터가 기록되는 동안 다른 프로세스에 의해 덮어 쓰여지는 경우 예외를 발생시킨다.

이벤트 소싱을 사용할 때 기존 이벤트를 읽고 새 이벤트를 작성하는 사이에 정확히 무슨 일이 일어났는지 더 깊은 통찰력을 얻을 수 있다. 이벤트 스토어에 동시에 추가된 정확한 이벤트를 추출하고 새로운 이벤트가 시도된 작업과 충돌하는지, 또는 추가 이벤트가 관련이 없고 계속 진행하는 것이 안전한지에 대해 비즈니소 도메인 주도 의사결정을 내릴 수 있다.

##### 단점

학습 곡선

패턴이 데이터를 관리하고 기존 기술과 엄청난 차이가 있다는 것은 명백한 단점이다. 패턴을 성공적으로 구현하려면 팀의 교육과 새로운 사고 방식에 익숙해지는 시간이 필요하다. 팀이 지금까지 이벤트 소싱 시스템을 구현한 경험이 없다면 학습 곡선을 고려해야 한다.

모델의 진화

이벤트 소싱 모델을 발전시키는 것은 어려울 수 있다. 이벤트 소싱의 정의를 엄밀하게 따지면 이벤트는 변경할 수 없다. 그렇다면 이벤틍의 스키마를 조정해야 하는 경우 어떻게 해야 할까? 그 과정은 테이블의 스키마를 변경하는 것 만큼 간단하지 않다.

아키텍처 복잡성

이벤트 소싱을 구현하면 수많은 아키텍처의 '유동적인 부분'이 도입되어 전체 설계가 더 복잡해진다.



#### 성능

---

**이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능에 부정적인 영향을 준다. 이벤트가 추가되면서 성능이 저하된다.**

이벤트를 상태 표현 방식으로 프로젝션하려면 실제로 컴퓨팅 성능이 필요하며 애그리게이트 목록에 더 많은 이벤트가 추가됨에 따라 그 필요성은 더 커진다.

프로젝션 과정이 성능에 미치는 영향을 벤치마킹하는 것이 중요하다. 벤치마킹 결과는 애그리게이트의 예상 수명과 비교해서 의사결정해야 한다.

대부분의 시스템에서 애그리게이트당 10,000개 이상의 이벤트가 있을 경우 성능 저하가 눈에 띄게 나타난다. 이 경우 스냅숏 패턴을 적용할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184746257-9d750656-99cb-4e7d-875d-00e13ea57ede.png)

이벤트 소싱 모델은 쉽게 확장할 수 있다. 모든 애그리게이트 관련 작업은 단일 애그리게이트 컨텍스트에서 수행되므로 이벤트 스토어는 애그리게이트 ID로 분할할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184746476-23bead7a-46ca-4751-847a-5eca94564664.png)

#### 데이터 삭제

----

**이벤트 스토어는 추가 전용 데이터베이스지만 물리적인 데이터를 삭제해야 하는 경우에는 어떻게 해야 할까?**

잊어버릴 수 있는 페이로드 패턴(forgettable payload pattern)으로 해결할 수 있다. 즉 , 모든 민감 정보는 암호화된 형식으로 이벤트에 포함한다. 암호화 키는 외부 키-값 저장소인 키 저장소에 저장한다. 여기서 키는 특정 애그리게이틍의 ID이고 값은 암호화 키다. 민감 데이터를 삭제해야 하는 경우 키 저장소에서 암호화 키를 삭제한다. 결과적으로 이벤트에 포함된 민감 정보에  이상 접근할 수 있다.



#### 결론

---

이벤트 소싱 도메인 모델에서 애그리게이트 상태에 대한 모든 변경사항은 일련의 도메인 이벤트로 표현한다.

결과 도메인 이벤트는 애그리게이트의 현재 상태를 프로젝션 하는데 사용할 수 있다.

이벤트 기반 모델은 이벤트를 특정 작업에 최적화된 여러 표현 모델로 프로젝션할 수 있는 유연성을 제공한다.

이 패턴은 분석과 최적화를 위해, 또는 법적으로 감사 로그를 요구하기 때문에 시스템 데이터에 대한 심오한 통찰력이 필요한 경우에 적합하다.



#### 느낀점

---

이벤트 소싱에 대해 대략적으로 이해를 하였지만 아직 생소한 개념이다.

또한 이를 적용함으로써 얻을 수 있는 이점에 대해 개념적으로는 이해되지만 공감되지는 않는다.