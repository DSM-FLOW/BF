### 09 _ 커뮤니케이션 패턴

---

#### 모델 변환

---

사용자 - 제공자 관계에서 권력은 업스트림 또는 다운스트림 바운디드 컨텍스트가 갖는다.

다운스트림 바운디드 컨텍스트가 업스트림 바운디드 컨텍스트 모델을 따를 수 없다고 가정한다.

이 경우 바운디드 컨텍스트의 모델을 변환하여 커뮤니케이션을 용이하게 하는 것 보다 더 정교한 기술 솔루션이 필요하다.

이 변환은 한쪽 또는 때로는 양쪽 모두에서 처리할 수 있다.



모델의 변환 로직은 스테리으티릇 또는 스테이트 풀이 될 수 있다.

- 상태를 보존하지 않는 스테이트리스 변환(stateless translation)은 수신(OHS) 또는 발신(ACL) 요청이 발생할 때 즉석에서 발생한다.
- 스테이트풀 변환(stateful translation)은 상태 보존을 위해 데이터베이스를 사용하여 좀 더 복잡한 로직을 다룰 수 있다.

##### 스테이트리스 모델 변환

---

스테이트리스 모델 변환을 소유하는 바운디드 컨텍스트는 프락시 디자인 패턴(proxy design pattern)을 구현하여 수신과 발신 요청을 삽입하고 소스 모델을 바운디드 컨텍스트의 목표 모델에 매핑한다.

![image](https://user-images.githubusercontent.com/80652992/185003974-980dc27d-2d0c-4b07-8ea4-6b257edf6270.png)

##### 동기

동기식 통신에 사용하는 모델을 변환하는 일반적인 방법은 바운디드 컨텍스트의 코드베이스에 변환 로직을 포함하는 것이다.

![image-20220817084714812](C:\Users\glay415as\AppData\Roaming\Typora\typora-user-images\image-20220817084714812.png)

경우에 따라 변환 로직을 API 게이트웨이 패턴과 같은 외부 컴포넌트로 넘기는 것이 더 비용 효과적이고 편할 수 있다.

오픈 호스트 패턴을 구현하는 바운디드 컨텍스트의 경우 API 게이트웨이는 내부 모델을 통합에 최적화된 공표된 언어로 변환하는 작업을 한다.

명시적 API 게이트웨이를 사용하면 바운디드 컨텍스트 API의 여러 버전을 관리하고 제공하는 프로세스를 도울 수 있다.

![image](https://user-images.githubusercontent.com/80652992/185004321-88050dc5-63ad-4892-8fa0-44e0f1cfda93.png)

API 게이트웨이를 사용하여 구현된 충돌 방지 계층은 여러 다운읏트림 바운디드 컨텍스트에서 사용할 수 있다. 이러한 경우 충돌 방지 계층은 통합 관련 바운디드 컨텍스트 역할을 한다.

![image](https://user-images.githubusercontent.com/80652992/185004489-3ce523e1-1acc-406d-bfb4-3466250ce3b7.png)

이러한 바운디드 컨텍스트는 주로 다른 컴포넌트에서 좀 더 편리하게 사용할 수 있게 모델을 변환하는 역할을 하며, 종종 교환 컨텍스트라고도 부른다.

##### 비동기

비동기 통신에 사용하는 모델을 변환하기 위해 메시지 프락시(message proxy)를 구현할 수 있다.

메시지 프락시는 소스 바운디드 컨텍스트에서 오는 메시지를 구독하는 중개 컴포넌트다.

프락시는 필요한 모델 변환을 적용하고 결과 메시지를 대상 구독자에게 전달한다.

![image](https://user-images.githubusercontent.com/80652992/185004644-cbd9672f-c85a-4b37-aded-903799509629.png)

메시지 모델을 변환하는 것 외에도 중개 컴포넌트는 관련 없는 메시지를 필터링 하여 목표 바운디드 컨텍스트의 노이즈를 줄일 수 있다.



비동기 변환을 사용하면 도메인 이벤트를 가로채서 공표된 언어로 변환할 수 있으므로 바운디드 컨텍스트의 구현 상세를 더 잘 캡슐화할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/185004823-0aa118de-f78e-44ea-926b-ad47a4815ee7.png)

메시지를 공표된 언어로 변환하면 바운디드 컨텍스트의 내부 요구사항을 위한 프라이빗 이벤트와 다른 바운디드 컨텍스트와 연동하기 위한 퍼블릭 이벤트를 구분할 수 있다.



##### 스테이트풀 모델 변환

---

더 중요한 모델 변환의 경우 스테이트풀 변환이 필요할 수 있다.

##### 들어오는 데이터 집계하기

바운디드 컨텍스트가 들어오는 요청을 집계하고 성능 최적화를 위해 일괄 처리에 관심이 있다고 가정해 보자.

이 경우 동기와 비동기 요청 모두에 대해 집계가 필요할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/185005121-7bbbe72a-4072-4df7-9a08-c7463658e5fa.png)

소스 데이터를 집계하는 또 다른 유스케이스는 여러 개의 세분화된 메시지를 단일 메시지로 결합하는 것이다.

![image](https://user-images.githubusercontent.com/80652992/185005147-d2080012-75ef-4b01-a043-6e58e8b5ee30.png)

유입되는 데이터를 집계하는 모델 변환은 API 게이트웨이를 활용할 수 없으므로 변환 로직 자체에 영구 저장소가 필요하다.

![image](https://user-images.githubusercontent.com/80652992/185005344-b6be0577-77db-4006-91c1-eed4de51cea6.png)

*일부 유스케이스에는 상용 제품을 사용하여 스테이트풀 변환을 위한 맞춤 제작 솔루션을 구현하지 않는 경우도 있다.

##### 여러 요청 통합

다른 바운디드 컨텍스트를 포함하여 여러 요청에서 집계된 데이터를 처해야 할 수 있다. 이에 대한 일반적인 예는 프런트엔드를 위한 백엔드 패턴이다.

바운디드 컨텍스트에서 데이터를 집계하는 충돌 방지 계층을 바운디드 컨텍스트 전면에 배치하여 바운디드 컨텍스트연동과 비즈니스 로직의 복잡성을 분리하는 것이 유리할 수 있다.



#### 애그리게이트 연동

---

애그리게이트가 시스템의 나머지 부분과 통신하는 방법 중 하나는 도메인 이벤트를 발행하는 것이다.

그렇다면 어떻게 도메인 이벤트가 메시지 버스에 발행될까?

##### 아웃박스

아웃박스 패턴은 다음 알고리즘을 사용하여 도메인 이벤트의 안정적인 발행을 보장한다.

- 업데이트된 애그리게이틍의 상태와 새 도메인 이벤트는 모두 동일한 원자성 트랜잭션으로 커밋된다.
- 메시지 릴레이는 데이터베이스에서 새로 커밋된 도메인 이벤트를 가져온다.
- 릴레이는 도메인 이벤트를 메시지 버스에 발행한다.
- 성공적으로 발행되면 릴레이는 이벤트를 데이터베이스에 발행한 것으로 표시하거나 완전히 삭제한다.

![image](https://user-images.githubusercontent.com/80652992/185006090-f2ef0384-fec9-44fd-97b3-3f119852281c.png)

관계형 데이터베이스를 사용할 때 두 개의 테이블에 원자적으로 커밋하고 메시지를 저장하기 위한 전용 테이블을 사용하는 데이터베이스의 기능을 활용하는 것이 좋다.

![image](https://user-images.githubusercontent.com/80652992/185006219-70e0d9c9-b522-41c1-8ed0-55136afa904d.png)

다중 문서 트랜잭션을 지원하지 않는 NoSql 데이터베이스를 사용할 때 전달될 도메인 이벤트는 애그리게이트 레코드에 포함되어야 한다.

##### 발행되지 않은 이벤트 가져오기

발행 릴레이는 풀 기반 또는 푸시 기반 방식으로 새 도메인 이벤트를 가져올 수 있다.

- 폴 : 발행자 폴링
- 푸시 : 트랜잭션 로그 추적

##### 사가

---

핵심 애그리게이트 설계 원칙 중 하나는 각 트랜잭션을 애그리게이틍의 단일 인스턴스로 제안하는 것이다.

여러 애그리게이트에 걸쳐 있는 비즈니스 프로세스를 구현해야 하는 경우가 있다. 이 흐름을 사가로 구현할 수 있다.

사가는 오래 지속되는 비즈니스 프로세스다. 즉 여러 트랜잭션에 걸쳐 있는 프로세를 말한다.

사가는 관련 컴포넌트에서 발생하는 이벤트를 수신하고 다른 컴포넌트에 후속 커맨드를 실행한다. 실행 단계 중 하나가 실패하면 사가는 시스템 상태를 일관되기 유지하므로 적절한 보상 조치를 내리는 일을 담당한다.

![image](https://user-images.githubusercontent.com/80652992/185006793-21844734-6ddc-4fa1-ab24-e973ce9de957.png)

- 발행 프로세스를 구현하기 위해 컴퍼니 애그리게이트부터 CampaignActivated, Adpublishing부터 PublishingConfirmed와 Rejected 이벤트를 기다린다.
- 사가는 AdPublishing에서 SubmitAdvertisement 커맨드를 실행하고 Campaign 애그리게이트에서 TrackPublishingConfirmation과 Rejection 커맨드를 실행해야 한다. 여기서 TrackPublishingRejection 커맨드는 보상조치 실행을 담당한다.

##### 일관성

*애그리게이트 경계 내의 데이터만 강한 일관성을 가진다. 외부의 모든 것은 궁극적으로 일관성을 가진다.*

사가가 다중 컴포넌트의 트랜잭션을 조율하지만 관련된 컴포넌틍의 상태는 궁극적으로 일관성을 가진다.

사가가 관련 커맨드를 실행한다 하여도 두 개의 트랜잭션은 원자적으로 간주되지 않는다.



부적절한 애그리게이트 경계를 보상하기 위해 사가를 남용하면 안된다.

동일한 애긜게이트에 속해야 하는 비즈니스 작업에는 강한 일관성을 갖는 데이터가 필요하다.

##### 프로세스 관계자

---

프로세스 관리자 패턴은 비즈니스 로직 기반 프로세스를 구현하기 위한 것이다.

프로세스 관리자는 시퀀스의 상태를 유지하고 다음 처리 단계를 결정하는 중앙 처리 장치로 정의한다.

![image](https://user-images.githubusercontent.com/80652992/185007502-4c46ca15-d430-44fb-9fc7-ab5763a9fbc1.png)

프로세스 관리자는 단일 소스 이벤트에 바인딩될 수 없다. 따라서 명시적으로 인스턴스화 해야한다.



#### 결론

---

이번장은 충돌 방지 계층 또는 오픈 호스트 서비스를 구현하는 데 사용할 수 있는 모델 변환 패턴을 살펴보았다.

아웃박스 패턴은 애그리게이트의 도메인 이벤트를 발행하는 안정적인 방법이며 다른 프로세스 실패에 직면해도 도메인 이벤트를 항상 발행한다.

사가 패턴은 간단한 교차 컴포넌트 비즈니스 프로세스를 구현하는 데 사용할 수 있다.

프로세스 관리자 패턴을 사용하여 좀 더 복잡한 비즈니스 프로세스를 구현할 수 있다.

사가 패턴과 프로세스 관리자 패턴모두 도메인 이벤트에 대한 비동기식 반응과 커맨드 실행에 의존한다.



#### 느낀점

---

이번장에선 앞서 나왔던 개념의 응용격인 내용에 대해 다뤘고 좀더 심화적인 탐구가 필요하다는 것을 느꼈다.