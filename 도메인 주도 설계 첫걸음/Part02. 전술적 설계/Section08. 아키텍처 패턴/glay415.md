### 08 _ 아키텍처 패턴

---

#### 비즈니스 로직과 아키텍처 패턴

---

비즈니스 로직은 소프트웨어에서 가장 중요한 요소다

코드베이스는 기능 또는 비기능 요구사항을 구현하기 위한 많은 책임을 담당한다.

아키텍처 패턴은 코드베이스의 다양한 측면에 대한 구성 원칙을 도입하고 이들 사이의 명확한 경계를 제시한다.

코드베이스를 조직하는 적절한 방법 혹은 올바른 아키텍처 패턴을 선택하는 것은 단기적으로는 비즈니스 로직 구현을 지원하고, 장기적으로 유지보수를 돕기 위해 매우 중요하다.



#### 계층형 아키텍처(layerd architecture)

---

계층형 아키텍처는 가장 일반적인 아키텍처 패턴 중 하나다. 코드베이스를 수평 계층으로 조직하고, 각 계층은 사용자와 상호작용, 비즈니스 로직의 구현, 그리고 데이텅의 저장과 같은 기술적 관심사 중 하나를 다룬다.

![image](https://user-images.githubusercontent.com/80652992/184793970-add87374-e7d6-47cf-b59d-3c90ce1e6e49.png)

고전적인 형태의 계층형 아키텍처는 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층을 가진다.

##### 프레젠테이션 계층

프레젠테이션 계층은 사용자와 상호작용을 하기 위한 프로그램의 사용자 인터페이스를 구현한다.

원래 형태에서의 프레젠테이션 계층은 웹 인터페이스 또는 데스크톱 인터페이스와 같은 그래픽 인터페이스를 나타낸다. 하지만 현대의 시스템에서는 프로그램의 동작을 촉발하는 모든 동기식 또는 비동기식 수단과 같은 좀 더 광번위한 범주를 포함한다.

- 그래픽 유저 인터페이스 GUI
- 커맨드 라인 인터페이스 CLI
- 다른 시스템과 연동하는 API
- 메시지 브로커에서 이벤트에 대한 구독
- 나가는 이벤트를 발행하는 메시지 토픽

엄밀히 말하면 프레젠테이션 계층은 프로그램의 퍼블릭 인터페이스다.

##### 비즈니스 로직 계층

이름에서 알 수 있듯이, 이 계층은 프로그램의 비즈니스 로직을 구현하고 묶는 것을 담당한다. 이곳에 비즈니스 의사결정을 구현한다.

이 계층이 소프트웨어의 중심이다.

##### 데이터 접근 계층

데이터 접근 계층은 영속성 매커니즘에 접근할 수 있게 해준다.

원래 패턴에서는 데이터 접근 계층은 시스템의 데이터베이스를 가르킨다. 그러나 현대 시스템에서는 이 계층이 좀 더 넓은 범위의 책임을 진다.

##### 계층 간 커뮤니케이션

각 계층은 톱다운 커뮤니케이션 모델에 따라 바로 아래 계층에만 의존한다.

##### 변종(variation)

계층형 아키텍처 패턴을 확장해서 서비스 계층을 추가하는 것을 흔히 볼 수 있다.

##### 서비스 계층

> "가용한 오퍼레이션을 구축하고 각 오퍼레이션에서 애플리케이션의 응답을 조정하는 서비스 계층을 애플리케이션의 경계에 정의한다." 
>
> **-** 엔터프라이즈 애플리케이션 아키텍처 패턴

서비스 계층은 프로그램으이 프레젠테이션 계층과 비즈니스 로직 계층 사이의 중간 역할을 한다.

아키텍처 패턴의 컨텍스트에서 서비스 계층은 논리적 경계라는 것이 중요하다.

서비스 계층을 명시적으로 갖추면 몇 가지 장점이 생긴다.

- 동일한 서비스 계층을 여러 퍼블릭 인터페이스에서 재사용할 수 있다. 예를 들어, 그래픽 유저 인터페이스와 API 등이다. 중복된 조율 로직이 필요 없게 된다.
- 모든 관련 메서드를 한곳에 모으면 모듈화가 개선된다.
- 프레젠테이션 계층과 비즈니스 로직 계층의 결합도를 낮춘다.
- 비즈니스 기능을 테스트하기 쉬워진다.

##### 용어

- 프레젠테이션 계층 = 사용자 인터페이스 계층
- 서비스 계층 = 애플리케이션 계층
- 비즈니스 로직 계층 = 도메인 계층 = 모델 계층
- 데이터 접근 계층 = 인프라스트럭쳐 계층

##### 계층형 아키텍처를 사용하는 경우

비즈니스 로직과 데이터 접근 계층 간에는 의존성이 있다. 따라서 비즈니스 로직이 트랜잭션 스크립트 또는 액티브 레코드 패턴을 사용하여 구현된 시스템에 계층형 아키텍처 패턴이 적합하다.

도메인 모델을 구현하는 데 계층형 아키텍처 패턴을 적용하는 것은 어렵다. 도메인 모델에서는 비즈니스 엔티티가 하부의 인프라스트럭처에 대해 의존성이 없어야 하고 그것을 몰라야 하기 때문이다.

##### 티어 아키텍처와의 차이

계층은 논리적인 경계인 반면, 티어는 물리적 경계다.

계층형 아키텍처에서 모든 계층은 동일한 수명주기를 갖지만 티어는 독립적으로 배포될 수 있는 서비스나 서버, 또는 시스템이다.



#### 포트와 어댑터(port & adapter)

---

포트와 어댑터 아키텍처는 계층형 아키텍처의 단점을 해결하고 좀 더 복잡한 비즈니스 로직을 구현하는데 적합하다.

![image](https://user-images.githubusercontent.com/80652992/184793922-7b58e243-39da-4861-8987-7c1934e56a38.png)

##### 용어

본질적으로 프레젠테이션 계층과 데이터 접근 계층 모두 데이터베이스, 외부 서비스, 사용자 인터페이스 프레임워크 등의 외부 구성요소와 연동하는 것을 표현한다. 하지만 이와 같은 기술적 구현 상세는 시스템의 비즈니스 로직을 반영하지 못하므로 모든 인프라 관심사를 단일 인프라스트럭쳐 계층으로 통합한다.

##### 의존성 역전 원칙

의존성 역전 원칙(DIP)에선 비즈니스 로직을 구현하는 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다고 말한다.

DIP를 적용하면 비즈니스 로직 계층은 프레젠테이션 계층과 데이터 접근 계층에 끼어 있는 대신, 중심적인 역할을 맡는다.

##### 인프라 구성요소의 연동

포트와 어댑터 아키텍처의 핵심 목적은 인프라스트럭처 구성요소로부터 시스템의 비즈니스 로직을 분리하는 것이다.

인프라스트럭처 구성요소를 직접 참조하고 호출하는 대신, 비즈니스 로직 계층은 인프라스트럭처 계층이 구현해야 할 '포트'를 정의한다. 인프라스트럭처 계층은 '어댑터'를 구현한다.

![image](https://user-images.githubusercontent.com/80652992/184794346-ca4a729b-0735-4ec7-9561-2823a890531f.png)

##### 변형

포트와 어댑터 아키텍처는 헥사고날, 어니언, 클린 아키텍처로 알려져 있다. 이 모든 패턴이 비록 동일한 설계 원칙을 기반하고 동일한 구성요소를 가지고 동일한 관계를 가진다 해도 계층형 아키텍처에서와 마찬가지로 용어는 다음과 같이 다를 수 있다.

- 애플리케이션 계층 = 서비스 계층 = 유스케이스 계층
- 비즈니스 로직 계층 = 도메인 계층 = 핵심 계층

##### 포트와 어댑터를 사용하는 경우

모든 기술적 관심사로부터 비즈니스 로직을 분리하는 것이 포트와 어댑터 아키텍처 목적이므로 이 아키텍처는 도메인 모델 패턴을 사용하여 구현한 비즈니스 로직에 매우 적합하다.



#### CQRS(command-query responsibility segregation)

---

CQRS 패턴은 포트와 어댑터와 동일한 비즈니스 로직과 인프라스트럭처 관심사에 기반한다. 하지만 시스템의 데이터를 관리하는 방식이 다르다. 이 패턴을 사용하면 여러 영속 모델에 시스템의 데이터를 표현할 수 있다.

##### 폴리글랏 모델링

대부분의 경우 단일 비즈니스 도메인 모델로 시스템의 모든 요구사항을 해결하기는 불가능하지는 않지만 어려울 수 있다.

완벽한 데이터베이스는 없다. 확장성이나 일관성, 또는 지원하는 질의 모델 간의 균형이 필요하다. 

완전한 데이터베이스의 대안으로 폴리그랏 영속성 모델이 있다. 이는 다양한 데이터 관련 요구사항을 구현하기 위해 여러 데이터베이스를 사용하는 것이다.

CQRS 패턴은 이벤트 소싱과 밀접하게 관련이 있다. 한 번에 하나의 애그리게이트 인스턴스에 대한 이벤트를 질의할 수 있다.

CQRS 패턴은 프로젝션된 모델을 물리적 데이터베이스에 머터리얼라이즈해서 유연한 질의에 사용할 수 있게 해준다.

##### 구현

이름에서 알 수 있듯이 이 패턴은 시스템 모델의 책임을 분리시킨다.

##### 커맨드 실행 모델

CQRS에는 시스템의 상태를 수정하는 오퍼레이션을 전담으로 수행하는 단일 모델이 있다. 이 모델은 비즈니스 로직을 구현하고 규칙을 검사하며 불변성을 강화하는 데 사용된다.

커맨드 실행 모델은 시스템의 원천인 강력환 일관성을 가진 데이터를 표현하는 유일한 모델이다.

##### 읽기 모델(프로젝션)

시스템은 사용자에게 데이터를 보여주거나 다른 시스템에 정보를 제공하기 위해 필요한 만큼 모델을 정의할 수 있다.

읽기 모델은 캐시에서 언제든 다시 추출할 수 있는 프로젝션이다.

잘 구현된 CQRS에서는 모든 프로젝션의 모든 데이터를 삭제하고 처음부터 다시 재생성할 수 있다. 또한 예측하지 못한 미래에 새로운 프로젝션을 시스템에 확장하는 것도 가능하다.

##### 읽기 모델의 프로젝션

읽기 모델이 작동하려면 시스템은 커맨드 실행 모델에서 변경을 모든 읽기 모델로 프로젝션해야 한다.

![image](https://user-images.githubusercontent.com/80652992/184891769-2168f456-6ac9-4aaf-858d-e6af47c51df3.png)

읽기 모델의 프로젝션은 관계형 데이터베이승의 머터리얼라이즈 뷰(materialized view)의 개념과 유사하다. 즉, 원천 테이블이 갱신되면 변경사항은 미리 작성된 뷰에 반영되어야 한다.

##### 동기식 프로젝션

동기식 프로젝션은 격차 해소 구독 모델(catch-up subscription) 을 통해 OLTP 데이터의 변경사항을 가져온다.

- 프로젝션 엔진이 OLTP 데이터베이스로부터 마지막에 처리했던 체크포인트 이후에 추가되거나 갱신된 레코드를 조회한다.
- 프로젝션 엔진이 조회된 데이터를 이용해서 시스템의 읽기 모델을 재생성 또는 갱신한다.
- 프로젝션 엔진은 마지막으로 처리 레코드의 체크포인트를 저장한다. 이 값은 다음 처리 때 추가되거나 갱신된 레코드를 조회하는 데 사용된다.

![image](https://user-images.githubusercontent.com/80652992/184893435-eab5750e-504e-4837-8412-1678e855c73c.png)

![image](https://user-images.githubusercontent.com/80652992/184893531-36ae8584-6d57-4792-bffc-5379baf758a9.png)

격차 해소 구독이 작동하려면 커맨드 실행 모델이 추가되거나 갱신되는 모든 데이터베이스 레코드를 체크포인트로 관리해야 하며 체크포인트 기반으로 레코드를 조회하는 것을 지원해야 한다.

##### 비동기식 프로젝션

비동기식 프로젝션 시나리오에서 커맨드 실행 모델은 모든 커밋된 변경사항을 메시지 버스에 발행한다.

시스템의 프로젝션 엔진은 발행된 메시지를 구독하고 일기 모델을 갱신하는 데 사용한다.

![image](https://user-images.githubusercontent.com/80652992/184895114-ef77a7d8-f7e9-4e11-8edd-79ce03208a74.png)

##### 도전과제

비동기식 프로젝션 방식의 확실한 확장성과 성능의 장점에도 불구하고, 분산 컴퓨팅에서 문제가 발생하기 더 쉽다.

메시지의 순서가 잘못되거나 중복 처리되면 읽기 모델에 일관성 없는 데이터가 프로젝션된다.

##### 모델 분리

CQRS 아키텍처에서 시스템 모델이 담당하는 책임은 그 타입에 따라 분리된다.

커맨드는 강한 일관성을 가진 커맨드 실행 모델에서만 동작한다. 

CQRS 기반 시스템에 대한 일반적인 오해는 커맨드가 데이터를 수정할 수 있고, 데이터를 오직 표현 용도로 읽기 모델을 통해서만 조회할 수 있다는 것이다.

커맨드는 실행이 성공했는지 또는 실패했는지를 항상 호출자에게 알려야 한다. 그러므로 대부분의 경우 커맨드를 데이터를 반환해야 한다.

##### CQRS를 사용해야 하는 경우

CQRS 패턴은 여러 모델, 궁극적으로 다양한 종류의 데이터베이스의 저장된 동일한 데이터와 작동할 필요가 있는 애플리케이션에 유용한다.

인프라스트럭처 관점에서는 CQRS가 다양한 종류의 데이터베이스의 장점을 활용할 수 있게 해준다.

CQRS는 이벤트 소싱 도메인 모델에도 적합하다. 이벤트 소싱 모델에서는 애그리게이틍의 상태에 기반한 레코드 조회가 불가능하지만 CQRS는 상태를 질의할 수 있는 데이터베이스의 상태를 프로젝션하므로 이것이 가능하다.



#### 범위

---

앞서 논의한 패턴은 시스템 전체에 적용하는 구성 원칙으로 취급하면 안 된다.

동일한 타입의 하위 도메인도 다양한 비즈니스 로직과 아키텍처 패턴이 필요할 수 있다. 바운디드 컨텍스트에 단일 아키텍처를 강요하면 의도치 않은 우발적 복잡성을 유발할 것이다.

![image](https://user-images.githubusercontent.com/80652992/184898120-12a7090f-35a2-4284-9783-ba195e54df21.png)

우리의 목적은 실제 필요성과 비즈니스 전략에 따라 설계 의사결정을 내리는 것이다. 시스템을 수평으로 분할하는 계층 외에도, 수직으로 나누는 것을 추가로 도입할 수 있다.

적절한 수직 경계는 모놀리식 바운디드 컨텍스트를 모듈화하고 커다란 진흙 덩어리가 되는 것을 방지할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184898650-fbf98cac-e070-47bc-82fc-ff040d698382.png)



#### 결론

---

계층형 아키텍처는 기술적 관심사에 따라 코드베이스를 분해한다. 이 패턴은 비즈니스 로직과 데이터 접근 구현을 결합시키므로 액티브 레코드 기반 시스템에 적합하다.

포트와 어댑터 아키텍처는 관계를 역전시킨다. 비즈니스 로직을 중심에 두고 모든 인프라스트럭처와의 의존성을 분리한다. 이 패턴은 도메인 모델 패턴을 구현하는 비즈니스 로직에 적합하다.

CQRS 패턴은 여러 모델에서 동일한 데이터를 표현한다. 이 패턴은 이벤트 소싱 도메인 모델에 기반한 시스템에 적합하지만 다양한 영속 모델을 사용할 필요가 있는 어떤 시스템에도 사용할 수 있다.



#### 느낀점

---

- 오랜만에 익숙한 개념이 나와서 반가웠다.
- CQRS는 아키텍처로 정의하게 모호한 개념이 아닐까 생각이 든다.