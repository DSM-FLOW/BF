### 06 _ 복잡한 비즈니스 로직 다루기

---

#### 도메인 모델

---

**도메인 모델은 CRUD 인터페이스 대신 복잡한 상태 전환, 항상 보호해야 하는 규칙인 비즈니스 규칙과 불변성을 다룬다.**

헬프데스크 시스템을 구현한다고 가정한다면 요구사항의 다향한 규칙이 그물 같은 의존성을 형성하고, 수명주기에 영향을 줄 수 있다.

만약 위 경우에서 액티브 레코드 객체를 사용하여 로직을 구현하면 로직이 중복되거나 일부 비즈니스 규칙이 잘못 구현되어 시스템의 상태를 손상시키기 쉽다.

##### 구현

도메인 모델은 행동과 데이터 모두를 포함하는 도메인의 객체 모델이다.

DDD의 전술 패턴인 애그리게이터, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스는 모두 객체모델의 구성요소다. 이 같은 모든 패턴은 비즈니스 로직을 최우선으로 둔다는 공통 관심사가 있다.

##### 복잡성

도메인 비즈니스 로직은 이미 본질적으로 복잡하므로 모델링에 사용되는 객체가 모델에 조금이라도 우발적 복잡성을 추가하면 안 된다.

모델에는 데이터베이스 또는 외부 시스템 구성요소의 호출 구현 같은 인프라 또는 기술적인 관심사를 피해야 한다.



*플레인 올드 오브젝트 : 위 제약사향을 충족한 모델의 객체, 인프라 구성 요소 또는 프레임워크에 의지하지 않고 비즈니스 로직을 구현하는 객체다.

##### 유비쿼터스 언어

도메인 모델의 객체가 비즈니스 로직에 집중하게 하면 바운디드 컨텍스트에서 사용하는 유비쿼터스 언어를 따르기 쉬워진다.



#### 밸류 오브젝트(VO)

---

**밸류 오브젝트는 복합적인 값에 의해 식별되는 객체다.**

```java
public class Color {
    int red;
    int green;
    int blue;
}
```

위 Color객체는 빨강, 녹색, 파랑의 세 필드 값이 복합적으로 색을 정의한다.

같은 값을 갖는 두 개 이상의 색은 존재하지 않으며 같은 색의 두 인스턴스는 반드시 같은 값을 갖는다. 따라서 색을 식별하기 위한 명시적인 식별 필드가 필요 없다.

##### 유비쿼터스 언어

언어의 표준 라이브러리에 포함된 문자열, 정수, 딕셔너리 같은 원시 데이터 타입에 전적으로 의존해서 비즈니스 도메인의 개념을 표현하는 것은 원시 집착 코드 징후로 알려져 있다.

```java
public class Person {
    private int id;
    private char[] landlinePhone;
    private char[] countryCode;
}
```

위 Person 클래스는 값의 대부분은 문자열 타입이고 관례에 따라 값이 할당 되었다.

Person 클래스의 필드에는 다음과 같은 제약이 있다.

- landlinePhone 필드의 값은 유효한 유선 전화번호여야 한다
- countrycode 필드는 두 자리의 대문자로 된 국가 코드여야 한다.

이러한 경우로 인해 클래스가 모든 입력 필드를 검사해야 한다. 하지만 이 방식에는 몇 가지 설계 위험이 있다.

- 유효성 검사 로직이 중복되기 쉽다.
- 값이 사용되기 전에 유효성 검사 로직을 호출하게 하기 어렵다.
- 다른 엔지니어가 코드베이스를 개선하는 것과 같은 미래를 대비한 유지보수가 더 어렵다.

``` java
public class Person {
    private PersonId id;
    private LandlinePhone landline;
    private CountryCode country;
}
```

위 코드는 밸류 오브젝트를 적용한 코드다.

밸류 오브젝트를 사용하면 짧은 변수 이름을 사용하더라도 의도를 명확하게 전달한다.

- country 변수는 완전한 국가 이름 대신 국가 코드를 저장한다는 의도를 전달하기 위해 countryCode처럼 상세한 변수명을 쓸 필요가 없다.

유효성 검사 로직이 밸류 오브젝트 자체에 들어 있기 때문에 값을 할당하기 전에 유효성 검사를 할 필요가 없다.

이렇게 응집된 로직은 한곳에서 구현되고 쉽게 테스트할 수 있다.

밸류 오브젝트를 사용하면 코드에서 유비쿼터스 언어를 사용하게 하므로 코드에서 비즈니스 도메인의 개념을 표현하게 된다.

##### 구현

벨류 오브젝트는 불변의 객체로 구현해야 한다. 즉 밸류 오브젝트의 필드 중 하나가 바뀌면 개념적으로 밸류 오브젝트의 다른 인스턴스가 생성된다.

밸류 오브젝트의 동일성은  id 필드나 참조 대신 값을 기반으로 하므로 동일성 검사 함수를 오버라이드해서 적절히 구현하는 것이 중요하다.

*닷넷, 자바 등의 언어는 문제열 타입을 정확하게 밸류 오브젝트로 구현했다. 문자열은 불변이므로 모든 오퍼레이션은 새로운 인스턴스를 만든다. 또한 문자열 타입은 trim, concatenate, replace, substring 등과 같이 메서드로 하나 이상의 문자열 값을 조작하여 새로운 인스턴스를 생성하는 풍부한 동작을 내포한다.

##### 밸류 오브젝트를 사용하는 경우

벨류 오브젝트는 가능한 모든 경우에 사용하는 게 좋다.

밸류 오브젝트는 코드의 표현력을 높여주고 분산되기 쉬운 비즈니스 로직을 한데 묶어줄 뿐만 아니라 코들르 더욱 안전하게 해준다.

밸류 오브젝트는 불변이기에 내표된 동작은 부작용과 동시성 문제가 없다.

비즈니스 도메인 관점에서 유용한 법칙은 다른 객체의 속성을 표현하는 도메인의 요소에 밸류 오브젝트를 사용하는 것이다.



#### 엔티티(Entity)

---

엔티티는 밸류 오브젝트와 정반대로 다른 엔티티와 구별하기 위해 명시적인 식별 필드가 필요하다.

``` java
public class Person {
	public PersonId id;
    public Name name;
    
    public Person(PersonId id, Name name) {
        this.id = id;
        this.name = name;
    }
    
    public getName() {
        return this.name;
    }
    
    public setName(Name name) {
        this.name = name;
    }
}
```

이 클래스에는 PersonId 타입의 Id 필드를 식별 필드로 도입했다.

PersonId는 밸류 오브젝트이고 비즈니스 도메인에서 필요한 모든 기본 데이터 타입을 사용할 수 있다.

식별 필드의 핵심 요구사항은 각 엔티티의 인스턴스마다 고유해야 한다는 점이다. 또한 대부분의 경우 식별 필드의 값은 엔티티의 생애주기 내내 불변이여야 한다.

밸류 오브젝트와는 반대로, 엔티티는 불변이 아니고 변할 것으로 예상된다. 또 다른 차이점은 밸류 오브젝트는 엔티티의 속성을 설명한다는 것이다.

*엔티티는 단독 구현하지 않고 애그리게이트 패턴의 컨텍스트에서만 엔티티를 구현한다.



#### 애그리게이트(aggregate)

---

**애그리게이트는 앤티티다. 즉, 명시적인 식별 필드가 필요하고 인스턴스 생애주기 동안 상태가 변할 것으로 예상된다. 하지만 애그리게이트는 단순한 엔티티가 아닌 그 이상이다.**

애그리게이트의 데이터는 변할 수 도 있기 때문에 이 패턴에는 데이터의 일관성을 유지하기 위해 해결해야 할 과제가 있다.

##### 일관성 강화

데이터의 일관성을 강화하려면 애그리게이트 패턴에서는 애그리게이트 주변에 명확한 경계를 설정해야 한다. 즉 애그리게이트는 일관성을 강화하는 경계다.

애그리게이트의 로직은 모든 들어오는 변경 요청을 검사해서 그 변경이 애그리게이트의 비즈니스 규칙에 위배되지 않게 해야 한다.



규현 관점에서의 데이터 일관성으 애그리게이트으이 비즈니스 로직을 통해서만 애그리게이트으이 상태를 변경하게 해야 강화된다.

애그리게이트 외부의 모든 프로세스와 객체는 애그리게이트의 상태를 읽을 수만 있고 애그리게이터의 퍼블릭 인터페이스에 포함된 관련 메서드를 실행해야만 상태를 변형할 수 있다. 이는 '어떤 것을 지시하는 명령'을 의미하는 뜻에서 커맨드라고 부른다.



커맨드는 다음 두 가지 방식으로 구현할 수 있다.

- 애그리게이트 객체에 평범한 퍼블릭 메서드로 구현한다.
- 커맨드의 실행에 필요한 모든 입력값을 포함하는 파라미터 객체로 표현한다.

어떤 방식으로 구현할지는 선호도 문제다.



애그리게이트의 퍼블릭 인터페이스는 입력값의 유효성을 검사하고 관련된 모든 비즈니스 규칙과 불변성을 강화하는 것을 담당한다.

또한 이와 같은 엄격한 경계는 애그리게이트와 관련된 모든 비즈니스 로직이 한곳, 즉 애그리게이트 자체에 구현되게 한다.

조율 동작에서 해야 할 모든 일은 결국 애그리게이트의 현재 상태를 적재해서 필요한 동작을 수행하고 수정된 상태를 저장할 후 오퍼레이션의 결과를 호출 자에게 반환하는 것이다.



동시성 관리는 관계형 데이터베이스나 도큐먼트 데이터베이스에서 구현할 수 있다. 즉 애그리게이트 데이터를 저장하는 데 쓰이는 데이터베이스가 동시성 ㅗ간리를 지원하는지 확인하는 것이 중요하다.

##### 트랜잭션 경계

애그리게이트의 상태는 자신의 비즈니스 로직을 통해서만 수정할 수 있기 때문에 애그리게이트가 트랜잭션 경계의 역할을 한다.

모든 애그리게이트 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리돼야 한다.

애그리게이트의 상태가 수정되면 모든 변경이 커밋되거나 모두 원래 상태로 돌아가야 한다.

다중 애그리게이트 트랜잭션을 지원하는 시스템 오퍼레이션은 없다고 봐야 한다. 애그리게이트의 상태 변경은 데이터베이스 트랜잭션 하나당 한 개의 애그리게이트로, 개별적으로만 커밋 될 수 있다.



트랜잭션별로 하나의 애그리게이트 인스턴스만 갖게 제한하면 애그리게이트의 경계가 비즈니스 도메인의 불변성과 규칙을 따르도록 신중히 설계하게 된다.

여러 애그리게이트에서 변경을 커밋해야 한다면 이는 잘못된 트랜잭션 경계의 신호이고 잘못된 애그리게이트의 경계다.

##### 엔티티 계층

엔티티는 독립적 패턴이 아닌 애그리게이트의 일부로서만 사용된다.

DDD에서는 비즈니스 도메인이 시스템 설계를 주도해야 한다고 말한다. 애그리게이트도 마찬가지다. 애그리게이트 패턴은 엔티티 계층 구조와 유사하게 모든 트랜잭션을 공유해서 일관성을 유지한다.



이 계층은 엔티티와 밸류 오브젝트를 모두 담고 있다. 이 요소들이 도메인의 비즈니스 로직 경계내에 있으면 동일한 애그리게이트에 속한다.

이 패턴은 동일한 트랜잭션 경계에 속한 비즈니스 엔티티와 밸류 오브젝트를 한데 묶기 때문에 '애그리게이트'로 명명됐다.



애그리게이트는 일관된 데이터에 대해 모든 조건을 엄격하게 검사하도록 확인한다. 그리고 애그리게이트 데이터의 모든 변경이 우너자적인 단일 트랜잭션을 수행되도록 보장하여 점검이 완료된 후 수정되지 못하게 한다. 

##### 다른 애그리게이트 참조하기

애그리게이트 내의 모든 객체는 같은 트랜잭션 경계를 공유하기 때문에 애그리게이트가 너무 커지면 성능과 확장 문제가 생길 수 있다.

데이터의 일관성은 애그리게이트의 경계를 설계하는 데 편리한 가이드 원칙이다. 애그리게이트의 비즈니스 로직에 따라 강력한 일관성이 필요한 정보만 애그리게이트에 포함돼야 한다. 그 밖에 궁극적으로 일관돼도 좋은 모든 정보는 애그리게이트 경계 밖에 다른 애그리게이트의 일부로 둔다.

애그리게이트를 가능한 작게 유지하고 애그리게이트의 비즈니스 로직에 따라 강력하게 일관적으로 상태를 유지할 필요가 있는 객체만 포함해야 한다.



외부 애그리게이트를 참조할 때 ID를 이요하는 이유는 객체가 애그리게이트 경계에 속하지 않음을 명확히 하고 각 애그리게이트가 자신의 트랜잭션 경계를 갖게 보장하기 위함이다.

##### 애그리게이트 루트

애그리게이트가 엔티티의 계층 구조를 대표하기 때문에 그중 하나만 애그리게이트의 퍼블릭 인터페이스, 즉 애그리게이트 루트로 지정돼야 한다.

애그리게이트 루트의 퍼블릭 인터페이스 외에도 외부에서 애그리게이트와 커뮤니케이션할 수 있는 다른 매커니즘이 있는데, 바로 도메인 이벤트다.

##### 도메인 이벤트

도메인 이벤트는 비즈니스 도메인에 일어나는 중요한 이벤트를 설명하는 메시지다.

도메인 이벤트는 이미 발생된 것이기 때문에 과거형을 명명하며 비즈니스 도메인에서 일어난 일을 설명하고 이벤트와 관련된 모든 필요한 데이터를 제공하는 목적을 가진다.

도메인 이벤트의 이름이 비즈니스 도메인에서 일어난 일을 간결하고 정확하게 반영하게 해야 한다.

도메인 이벤트는 애그리게이트의 퍼블릭 인터페이스의 일부다. 애그리게이트는 자신의 도메인 이벤트를 발행하며 다른 프로세스, 애그리게이트, 심지어 외부 시스템도 이 도메인 이벤트를 구독할 수 있고 도메인 이벤트에 반응하는 자신만의 로직을 실행할 수도 있다.

##### 유비쿼터스 언어

애그리게이트는 유비쿼터스 언어를 사용해야 한다. 애그리게이트의 이름, 데이터, 멤버, 동작 그리고 도메인 이벤트에 사용된 모든 용어는 모두 바운디드 컨텍스트의 유비쿼터스 언어로 명명돼야 한다.



#### 도메인 서비스

---

**애그리게이트와 밸류 오브젝트에도 속하지 않거나 복수의 에그리게이트에 관련된 비즈니스 로직을 다루게 된다면 DDD는 도메인 서비스로 로직을 구현할 것을 제안한다.**

도메인 서비스는 비즈니스 로직을 구현한 상태가 없는 객체다. 대부분의 경우 이런 로직은 어떤 계산이나 분석을 수행하기 위한 다양한 시스템 구성요소의 호출을 조율한다.

도메인 서비스는 여러 애그리게이트의 작업을 쉽게 조율할 수 있다.

한 개의 데이터베이스 트랜잭션에서 한 개의 애그리게이트 인스턴스만 수정할 수 있다고 했던 애그리게이트 패턴의 한계를 명심해야 한다. 대신 도메인 서비스는 여러 애그리게이트의 데이터를 읽는 것이 필요한 계산 로직을 구현하는 것을 도와준다.

또한 도메인 서비스는 MSA, SOA 또는 소프트웨어 엔지니어링에서 '서비스' 용어를 사용하는 대부분의 것과 아무런 상관이 없다. 도메인 서비스에는 비즈니스 로직에서 양되는 상태가 없는 객체일 뿐이다.



#### 복잡성 관리

---

애그리게이트와 밸류 오브젝트 패턴은 비즈니스 불변성을 통해 자유도를 억제해 로직 구현의 복잡성을 다루는 수단으로서 도입됐다.

밸류 오브젝트의 상태와 관련된 모든 비즈니스 로직은 자신의 경계 안에 있다. 

애그리게이트는 자신의 메서드를 통해서만 수정된다.

비즈니스 로직은 비즈니스 불변성을 감싸고 보호해서 결국 자유도를 줄인다.

도메인 모델 패턴은 복잡한 비즈니스 로직을 갖는 하위 도메인에만 적용되므로 이를 소프트웨어의 중심인 핵심 하위 도메인으로 가정해도 좋다.



#### 결론

---

**벨류 오브젝트**

이것은 값만으로 식별되는 비즈니스 도메인의 개념이기 때문에 명시적인 실별 필드가 필요없다. 필드 중 하나가 변경되면 의미상 새로운 값을 생성하므로 밸류 오브젝트는 불변이다.

밸류 오브젝트는 데이터뿐만 아니라 행동도 모델링한다. 즉, 메서드는 값을 조작하고 새로운 밸류 오브젝트를 초기화한다.

##### 애그리게이트

트랜잭션 경계를 공유하는 엔티티의 계층이다. 애그리게이트의 경계에 속하는 모든 데이터는 비즈니스 로직의 구현을 통해 강력한 일관성을 유지해야 한다.

애그리게이트의 상태와 내부 객체는 애그리게이트의 커맨드를 실행하여서만 수정될 수 있다. 애그리게이트와 관련된 모든 비즈니스 로직이 경계 내에 존재하도록 외부 컴포넌트는 애그리게이트 내의 데이터 필드를 읽을 수만 있게한다.

애그리게이트는 도메인 이벤트를 게시하여 외부 엔티티와 커뮤니케이션할 수 있다. 도메인 이벤트는 에그리게이트의 수명주기에서 중요한 비즈니스 이벤트를 설명하는 메시지다. 다른 컴포넌트는 이벤트를 구독하고 비즈니스 로직의 실행을 촉발하는 데 사용할 수 있다.

##### 도메인 서비스

도메인 서비스란 도메인 모델에서 애그리게이트 또는 밸류 오브젝트에 속하지 않는 비즈니스 로직을 담는 상태가 없는 객체다.



#### 느낀점

---

- 드디어 DDD의 핵심 요소를 배운거 같아 감회가 새롭다.
- 애그리게이트를 코드상에서 어떻게 효과적으로 표현할 수 있을지 고민해봐야 겠다.