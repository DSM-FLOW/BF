### 04 _ 바운디드 컨텍스트 연동

---

바운디드 컨텍스트의 모델은 서로 독립적으로 발전하고 구현될 수 있다. 하지만 바운디드 컨텍스트 자체는 독립적이지 않다.

서로 독립적으로 발전할 수 있지만, 상호작용해야 한다.

**결국, 바운디드 컨텍스트 사이에는 항상 접점이 있는데 이것을 컨트랙트(contract)라고 부른다.**

#### 협력형 패턴 그룹

---

협력형 그룹의 패턴은 소통이 잘 되는 팀에서 구현된 바운디드 컨텍스트와 관련이 있다.

한 팀의 성공이 다른 팀의 성공에 달려있고, 그 반대도 마찬가지인 의존적 목표가 있는 팀에 해당된다. 다시 말해, 이 패턴이 적합한 요건은 팀의 커뮤니케이션과 협업의 수준에 있다.

##### 파트너십 패턴

파트너십 모델에서 바운디드 컨텍스트 간의 연동은 애드혹 방식으로 조정한다.

한 팀은 다른 팀에게 API의 변경을 알리고 다른 팀은 충돌 없이 이를 받아들인다.

![image](https://user-images.githubusercontent.com/80652992/184067992-5ad3aae6-74ff-482e-b241-1fb33f930d05.png)

여기서 연동의 조정은 양방향에서 한다.

- 양 팀은 차이점을 함께 해결하고 가장 적절한 솔루션을 선정한다.
- 발생할 수 있는 연동의 문제를 해결하는데 양 팀 모두 협력한다.

성공적인 연동을 위해서 필요한 요소는 다음과 같다.

- 잘 구축된 협업 실무
- 높은 수준의 헌신
- 팀 같은 잦은 동기화
- 양 팀이 적용한 변경사항의 지속적인 통합

*이런 패턴은 동기화와 커뮤니케이션의 어려움으로 지리적 위치에 영향을 받을 수 있다.

##### 공유 커널 패턴

공유 커널과 같은 공유 모델은 모든 바운디드 컨텍스트의 필요에 따라 설계된다. 또한 공유 모델은 이를 사용하는 모든 바운디드 컨텍스트에 걸쳐서 일관성을 유지해야 한다.



사용자의 권한을 관리하는 모델을 내부에서 개발해 사용하는 기업 시스템을 예로 들면 다음과 같다.

![image](https://user-images.githubusercontent.com/80652992/184075208-9178b8e4-1cd2-4bd0-9eaf-9a5670ccac0e.png)

각각의 사용자는 권한을 직접 부여받거나 소속된 단위 조직에 상속받는다. 각 바운디드 컨텍스트는 권한 모델을 수정할 수 있고 이 변경을 다른 컨텍스트에 영향을 준다.

##### 공유 범위

겹치는 형태의 모델은 해당되는 바운디드 컨텍스트의 수명 주기도 서로 엮이게 한다.

변경의 연쇄 영향을 최소화하려면 겹치는 모델을 제한해 공통으로 구현해야 하는 일부분만 모델에서 노출하도록 해야 한다.

##### 구현

공유 커널은 소스코드의 모든 변경이 즉시 연동되도록 구현해야 한다. 이를 지키지 않으면 모델의 일관성이 깨질 수 있다.

##### 공유 커널을 사용해야 하는 이유

*공유 커널의 적용 여부를 결정하는 가장 중요한 기준은 중복 비용과 조율 비용의 비율 이다.*

이 패턴을 적용할 경우 바운디드 컨텍스트간의 강한 의존성을 만들기 때문에 중복 비용(통합 비용)이 조율 비용보다 큰 경우에만 적용해야 한다.

*중복 비용의 차이는 모델의 변동성에 달려 있다.*

변경이 잦을수록 통합 비용이 높아지기에 자연스럽게 공유 커널은 핵심 하위 도메인처럼 많이 변하는 하위 도메인에 적용된다.'



*어떤 의미에서 보면, 공유 커널 패턴은 바운디드 컨텍스트 원칙에 위배된다.*

같은 팀이 공유 커널을 구현하지 않는다면 단일 팀 원칙을 위배하는 것일 수 있다.

겹치는 형태의 모델인 공유 커널은 사실상 여러 팀이 함께 개발한다.

그렇기에 공유 커널을 사용하는 데는 명분이 필요하다.

일반적으로 공유커널을 구현하는 적용 사례는 지리적인 제약이나 조직의 정치적인 문제로 커뮤니케이션 또는 협업이 어려워서 파트너십 패턴을 구현하기 어려울 때, 또는 레서시 시스템을 점진적으로 현대화 할 경우다.

적절한 조율 없이 밀접하게 연결된 기능을 구현하면 통합 문제, 모델의 동기화 문제, 설계 의사결정에 대한 논쟁 등의 문제를 발생시킨다. 따라서 매번 변경할 때마다 통합 테스트를 돌리는게 좋다.



#### 사용자 - 제공자 패턴 그룹

----

제공자는 사용자에게 서비스를 제공한다. 서비스 제공자는 upstreaem 이고 고색 또는 사용자는 downstream이다.

![image](https://user-images.githubusercontent.com/80652992/184075261-c6b9eb59-92a7-4d71-95b2-afdc1ebaad29.png)

협업 그룹 경우와는 다르게 양 팀은 서로 독립적으로 성공할 수 있다. 그러나 연동 컨트랙트를 주도하는 권력의 불균형이 존재한다.

##### 순응주의자 패턴

힘의 균형이 서비스를 제공사는 업스트림 팀에 있는 경우다.

제공자의 모델에 따라 정의된 연동 컨트랙트를 제공할 뿐이므로 사용자의 선택지는 이를 받아들이거나 떠나거나 둘 중 하나다.

![image](https://user-images.githubusercontent.com/80652992/184071452-82d737cf-2abc-4abe-8f70-a153d11edad2.png)

##### 충돌 방지 계층 패턴

다운스트림 바운디드 컨텍스트가 순응주의자 패턴에 순응하지 않는 경우 충돌 방지 계층을 통해 업스트림 바운디드 컨텍스트 모델을 스스로의 필요에 맞게 가공할 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184071640-5a116797-6e0d-458e-aae4-27c88d3d40bc.png)

충돌 반지 계층(anticorruption layer)패턴은 다음 사례와 같이 제공자의 모델을 따르는 것을 원치 않거나 순응에 필요한 노력이 가치가 없는 경우를 다룬다.

- 다운스트림 바운디드 컨텍스트가 핵심 하위 도메인을 포함할 경우
- 업스트림 모델이 사용자의 요건에 비효율적이거나 불편한 경우
- 제공자가 컨트랙트를 자주 변경하는 경우

모델링 관점에서 볼 때 다운스트림 사용자가 제공자의 모델을 변환하면 자신의 바운디드 컨텍스트와 상관없는 외부의 개념으로부터 다운스트림 사용자를 안전하게 보호할 수 있다.

##### 오픈 호스트 서비스 패턴

이 패턴은 힘이 사용자 측에 있을 경우를 처리한다. 제공자는 사용자를 보호하고 가능한 최고의 서비스를 제공하는 데 관심이 있다.

구현 모델의 변경으로부터 사용자를 보호하기 위해 업스트림 제공자는 퍼블릭 인터페이스와 구현 모델을 분리한다.

외부에 제공되는 퍼블릭 모델과 그 내부 구현을 다른속도로 발전시킬 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184072944-71c9d72e-dd01-472c-9d8f-40209b765ddc.png)

제공자의 퍼블린 인터페이스는 연동 지향 언어를 통해 사용자에게 더 편리한 프로토콜을 노출 시킨다. 이런 퍼블릭 프로토콜을 공표된 언어(published language)라고 한다.

오픈 호스트 서비스 패턴은 충돌 방지 계층 패턴의 반대다. 사용자 대신 제공자가 내부 모델 번역을 구현한다.

![image](https://user-images.githubusercontent.com/80652992/184075331-1bfee143-b38d-4e48-be1c-2542f1a6d736.png)

연동 모델을 분리하면 업스트림 바운디드 컨텍스트는 이미 공표된 언어의 여러 버전을 동시에 노출할 수 있어서 사용자가 점진적으로 새로운 언어로 이관할 수 있게 한다.



#### 분리형 노선

---

분리형 노선(separated ways)패턴에는 팀의 협업 의지가 없거나 협업할 수 없는 경우 다음과 같은 이유가 있다.

##### 커뮤니케이션 이슈

협업을 회피하는 일반적인 이유는 조직의 규모와 내부 정치 요인으로 인한 커뮤니케이션의 어려움 때문이다.

이런 어려움을 겪고 있다면 여러 바운디드 컨텍스트 내에서 기능을 중복해서 가져가고 각자의 길을 가는 것이 더 비용 효과적이다.

##### 일반 하위 도메인

중복된 하위 도메인의 특성도 협업 없이 분리된 길을 가야하는 이유가 있다.

읿잔 하위 도메인이 일반 솔루션과 연동하는 것이 쉽다면 각 바운디드 컨텍스트 내에서 각자 연동하는 것이 더욱 비용 효과적일 수 있다.

##### 모델의 차이

바운디드 컨텍스트의 모델 간의 차이도 협업 없이 분리된 길을 가야 하는 이유가 될 수 있다.

모델이 너무 달라서 순응주의자 관계가 불가능하고 충돌 방지 계층을 구현하는 것도 기능 중복보다 비용이 더 클 수 있다. 이런 경우에도 팀이 각자의 길을 가는 것이 더욱 비용 효과적이다.



#### 컨텍스트 맵

---

시스템의 바운디드 컨텍스트 간의 연동 패턴을 분석하면 다음과 같은 컨텍스트 맵으로 그릴 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184075386-cd8d5de6-a2bd-4b1e-a7c9-9d77a88a4129.png)

컨텍스트 맵은 시스템의 바운디드 컨텍스트와으이 연동을 시각적으로 표현한다.

시각적 표기법은 다음과 같은 통찰력을 제공한다.

- 거시적 설계 관점
- 커뮤케이션 패턴
- 조직적 문제

##### 유지보수

컨텍스트 맵은 프로젝트 초기부터 도입해서 새로운 바운디드 컨텍스트와 기존 요소에 대한 수정을 반영하는 것이 이상적이다.

컨텍스트 맵은 여러 팀과 작업한 정보를 담기에 다 함께 유지보수하는 것이 제일 좋다.

컨텍스트 앱은 컨텍스트 매퍼와 같은 도구를 사용해 코드로 관리할 수 있다.

##### 한계

컨텍스트 맵을 작성하는 것은 어려운 작업이다. 여러 하위 도메인에 걸친 시스템의 바운디드 컨텍스트에는 자동하지 않는 여러 패턴이 있을 수 있다.

![image](https://user-images.githubusercontent.com/80652992/184075081-f283762a-a6c3-47c1-b6a8-eb6ca7761f83.png)

또한 바운디드 컨텍스트가 단일 하위 도메인에 국한되더라도, 예를 들어, 하위 도메인의 모듈에 다른 통합 전략을 필요로 하는 경우 여전히 여러 통합 패턴이 있을 수 있다.



#### 결론

---

파트너십 : 바운디드 컨텍스트는 애드혹 방식으로 연결된다.

공유 커널 :  두 개 이상의 바운디드 컨텍스트가 참여하는 모든 바운드디드 컨텍스트가 공유하는 제한적으로 겹치는 모델을 공유해서 연동한다.

순응주의자 : 사옹자는 서비스 제공자의 모델에 순응한다.

충돌 방지 계층 : 사용자는 서비스 제공자의 모델을 사용자의 요건에 맞게 번역한다.

오픈 호스트 서비스 : 서비스 제공자는 사용자의 요건에 최적화된 모델인 공표된 언어를 구현한다.

분리형 노선 : 협력과 연동보다 특정 기능을 중복으로 두는 것이 더 저렴한 경우다.

바운디드 컨텍스트 간의 연동은 컨텍스트 맵으로 표현된다. 이를 통해 시스템의 거시적 설계 관점, 커뮤니케이션 패턴, 그리고 조직 문제에 대한 통찰력을 얻을 수 있다.



#### 느낀점

---

생소한 개념들을 배우면서 이번 장은 개발자보다 기획자에 초점 되어 있다는 것을 깨달았다.

또 soa, msa와 ddd가 추구하는 방향성이 비슷하다는 느낌을 받았다.